<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topology Gradient Mapper (Google Maps API - GET, Explicit Redirect)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { height: 500px; width: 100%; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .leaflet-container { background-color: #f0f0f0; }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-lg shadow-xl w-full max-w-2xl">
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-800 mb-6">Topology Gradient Mapper</h1>
        <div class="space-y-4 mb-6">
            <div>
                <label for="address" class="block text-sm font-medium text-gray-700 mb-1">Street Address:</label>
                <input type="text" id="address" name="address" placeholder="e.g., 1600 Amphitheatre Parkway, Mountain View, CA"
                       class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="acres" class="block text-sm font-medium text-gray-700 mb-1">Acres around property:</label>
                <input type="number" id="acres" name="acres" placeholder="e.g., 10.5" step="0.1" min="0.1"
                       class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
        </div>

        <button id="processButton"
                class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2.5 px-4 rounded-md shadow-md
                       transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50
                       flex items-center justify-center">
            <span id="buttonText">Visualize Gradient</span>
            <div id="spinner" class="spinner ml-3 hidden"></div>
        </button>

        <div id="messageArea" class="mt-4 text-sm text-center"></div>

        <div id="mapContainer" class="mt-6 hidden">
            <div id="map"></div>
        </div>
    </div>

    <footer class="text-center text-gray-500 mt-8 text-xs">
        <p>Uses Google Geocoding & Elevation APIs. Map by Leaflet.</p>
    </footer>

    <script>
        // --- Configuration ---
        const Maps_API_KEY = "AIzaSyDM6-JwBW9c3E-udm-oUl9XRWGaRWbcc-w"; // Your current working API KEY
        const NUM_POINTS_SIDE = 25; 
        const ACRE_TO_SQ_METERS = 4046.86;
        const GOOGLE_ELEVATION_POINTS_LIMIT = 300; // Reduced limit for GET requests
        const REQUEST_TIMEOUT_MS = 30000; 

        let map = null;
        let heatLayer = null;
        let propertyMarker = null;
        let boundsRectangle = null;
        let lastMessageIsUniformElevationWarning = false;

        const addressInput = document.getElementById('address');
        const acresInput = document.getElementById('acres');
        const processButton = document.getElementById('processButton');
        const buttonText = document.getElementById('buttonText');
        const spinner = document.getElementById('spinner');
        const messageArea = document.getElementById('messageArea');
        const mapContainer = document.getElementById('mapContainer');

        processButton.addEventListener('click', handleProcessRequest);

        function showMessage(text, isError = false, isWarning = false) {
            messageArea.textContent = text;
            let textColor = 'text-green-600';
            if (isError) textColor = 'text-red-600';
            else if (isWarning) textColor = 'text-yellow-700';
            messageArea.className = `mt-4 text-sm text-center ${textColor}`;
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                buttonText.textContent = 'Processing...';
                spinner.classList.remove('hidden');
                processButton.disabled = true;
                addressInput.disabled = true;
                acresInput.disabled = true;
                lastMessageIsUniformElevationWarning = false;
            } else {
                buttonText.textContent = 'Visualize Gradient';
                spinner.classList.add('hidden');
                processButton.disabled = false;
                addressInput.disabled = false;
                acresInput.disabled = false;
            }
        }

        async function geocodeAddressWithGoogle(addressStr) {
            showMessage("Geocoding address with Google...", false);
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(addressStr)}&key=${Maps_API_KEY}`;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
                const response = await fetch(url, { 
                    signal: controller.signal,
                    redirect: 'follow' // Explicitly follow redirects
                });
                clearTimeout(timeoutId);

                const data = await response.json();
                if (data.status === "OK" && data.results && data.results.length > 0) {
                    const location = data.results[0].geometry.location;
                    showMessage(`Geocoded: (${location.lat.toFixed(5)}, ${location.lng.toFixed(5)})`, false);
                    return { latitude: location.lat, longitude: location.lng };
                } else {
                    throw new Error(`Google Geocoding API Error: ${data.status}. ${data.error_message || ''}`);
                }
            } catch (error) {
                console.error("Google Geocoding error:", error);
                let errMsg = `Geocoding error: ${error.message}`;
                if (error.name === 'AbortError') errMsg = "Geocoding request timed out.";
                showMessage(errMsg, true);
                return null;
            }
        }
        
        function getGridPointsAndSteps(centerLat, centerLon, acres, numPointsSide) {
            const areaSqMeters = acres * ACRE_TO_SQ_METERS;
            const sideLengthMeters = Math.sqrt(areaSqMeters);
            const halfSideMeters = sideLengthMeters / 2.0;
            const mPerDegLat = 111132.954; 
            const mPerDegLon = mPerDegLat * Math.cos(centerLat * Math.PI / 180);

            if (mPerDegLon === 0) {
                showMessage("Cannot calculate longitude span at the poles.", true); return null;
            }

            const deltaLatDeg = halfSideMeters / mPerDegLat;
            const deltaLonDeg = halfSideMeters / mPerDegLon;
            const minLat = centerLat - deltaLatDeg;
            const maxLat = centerLat + deltaLatDeg;
            const minLon = centerLon - deltaLonDeg;
            const maxLon = centerLon + deltaLonDeg;
            const boundingBoxCoords = [minLat, minLon, maxLat, maxLon];

            const latPoints = [];
            const lonPoints = [];
            const latStep = (numPointsSide > 1) ? (maxLat - minLat) / (numPointsSide - 1) : 0;
            const lonStep = (numPointsSide > 1) ? (maxLon - minLon) / (numPointsSide - 1) : 0;

            for (let i = 0; i < numPointsSide; i++) {
                latPoints.push(minLat + i * latStep);
                lonPoints.push(minLon + i * lonStep);
            }
            if (numPointsSide === 1) { latPoints[0] = centerLat; lonPoints[0] = centerLon; }
            
            const gridPointsForApi = []; 
            latPoints.forEach(latVal => {
                lonPoints.forEach(lonVal => {
                    gridPointsForApi.push({ lat: parseFloat(latVal.toFixed(6)), lng: parseFloat(lonVal.toFixed(6)) });
                });
            });
            
            const latSpacingMeters = sideLengthMeters / (numPointsSide > 1 ? numPointsSide - 1 : 1);
            const lonSpacingMeters = sideLengthMeters / (numPointsSide > 1 ? numPointsSide - 1 : 1);

            if (!lastMessageIsUniformElevationWarning) {
                 showMessage(`Grid defined: ${numPointsSide}x${numPointsSide} points. Approx. spacing: ${latSpacingMeters.toFixed(1)}m.`, false);
            }
            return { gridPointsForApi, latSpacingMeters, lonSpacingMeters, boundingBoxCoords };
        }

        async function getElevationsWithGoogle(pointsForApi) { 
            if (!pointsForApi || pointsForApi.length === 0) return [];
            showMessage(`Querying Google Elevation API for ${pointsForApi.length} points via GET... (may require multiple batches)`, false);
            
            let allElevations = [];
            const numBatches = Math.ceil(pointsForApi.length / GOOGLE_ELEVATION_POINTS_LIMIT);

            for (let i = 0; i < numBatches; i++) {
                const batchStart = i * GOOGLE_ELEVATION_POINTS_LIMIT;
                const batchEnd = batchStart + GOOGLE_ELEVATION_POINTS_LIMIT;
                const batchPointsObjects = pointsForApi.slice(batchStart, batchEnd);
                
                const locationsParamString = batchPointsObjects.map(p => `${p.lat},${p.lng}`).join('|');
                const url = `https://maps.googleapis.com/maps/api/elevation/json?locations=${locationsParamString}&key=${Maps_API_KEY}`;
                                
                showMessage(`Fetching elevation batch ${i+1} of ${numBatches} via GET... (URL length: ${url.length})`, false);
                console.log("Requesting Elevation URL (GET):", url);

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
                    const response = await fetch(url, { 
                        method: 'GET',
                        signal: controller.signal,
                        redirect: 'follow' // Explicitly follow redirects
                    });
                    clearTimeout(timeoutId);

                    const data = await response.json();
                    console.log(`Google Elevation API Response (Batch ${i+1} GET):`, JSON.stringify(data, null, 2));

                    if (data.status === "OK" && data.results) {
                        const elevationsFromBatch = data.results.map(result => result.elevation);
                        allElevations.push(...elevationsFromBatch);
                    } else {
                         throw new Error(`Google Elevation API Error (Batch ${i+1} GET): ${data.status}. ${data.error_message || ''}`);
                    }
                } catch (error) {
                    console.error("Google Elevation API error (GET):", error); 
                    let errMsg = `Elevation fetching error (Batch ${i+1} GET): ${error.message}`; 
                    if (error.name === 'AbortError') errMsg = `Elevation request (Batch ${i+1} GET) timed out.`;
                    showMessage(errMsg, true);
                    return null; 
                }
            }
            
            if (allElevations.length > 0) {
                const validElevs = allElevations.filter(e => e !== null && e !== undefined && !isNaN(e));
                const allSame = validElevs.length > 0 && validElevs.every(e => e === validElevs[0]);

                if (allSame) {
                    let uniformMessage = `All fetched elevation points are uniformly ${validElevs[0].toFixed(2)}m. This will result in a calculated gradient of zero everywhere.`;
                    showMessage(uniformMessage, false, true);
                    lastMessageIsUniformElevationWarning = true;
                } else if (!lastMessageIsUniformElevationWarning) {
                     showMessage(`Elevations received for ${allElevations.length} points from Google.`, false);
                }
            } else if (!lastMessageIsUniformElevationWarning && allElevations.length === pointsForApi.length) {
                 showMessage(`Elevations received for ${allElevations.length} points from Google.`, false);
            } else if (!lastMessageIsUniformElevationWarning && allElevations.length !== pointsForApi.length) {
                 showMessage(`Partial or no elevation data received. Expected ${pointsForApi.length}, got ${allElevations.length}. Check console.`, true);
            }
            return allElevations;
        }

        function calculateGradientMagnitudes(elevationList, numPointsSide, latSpacingMeters, lonSpacingMeters) {
             if (!elevationList || elevationList.length !== numPointsSide * numPointsSide) {
                showMessage("Invalid elevation list or mismatch for gradient calculation.", true);
                return null;
            }
            if (latSpacingMeters <= 0 || lonSpacingMeters <= 0) {
                showMessage("Point spacing must be positive for gradient calculation.", true);
                return null;
            }

            if (!lastMessageIsUniformElevationWarning) {
                showMessage("Calculating gradient magnitudes...", false);
            }
            const elevationGrid = [];
            for (let i = 0; i < numPointsSide; i++) {
                elevationGrid.push(elevationList.slice(i * numPointsSide, (i + 1) * numPointsSide));
            }

            const gradLat = Array(numPointsSide).fill(null).map(() => Array(numPointsSide).fill(0));
            const gradLon = Array(numPointsSide).fill(null).map(() => Array(numPointsSide).fill(0));

            for (let i = 1; i < numPointsSide - 1; i++) {
                for (let j = 1; j < numPointsSide - 1; j++) {
                    gradLat[i][j] = (elevationGrid[i+1][j] - elevationGrid[i-1][j]) / (2 * latSpacingMeters);
                    gradLon[i][j] = (elevationGrid[i][j+1] - elevationGrid[i][j-1]) / (2 * lonSpacingMeters);
                }
            }

            for (let k = 0; k < numPointsSide; k++) {
                if (k > 0 && k < numPointsSide - 1) { 
                    gradLon[0][k] = (elevationGrid[0][k+1] - elevationGrid[0][k-1]) / (2 * lonSpacingMeters);
                    gradLon[numPointsSide-1][k] = (elevationGrid[numPointsSide-1][k+1] - elevationGrid[numPointsSide-1][k-1]) / (2 * lonSpacingMeters);
                } else if (k === 0) { 
                    gradLon[0][k] = numPointsSide > 1 ? (elevationGrid[0][k+1] - elevationGrid[0][k]) / lonSpacingMeters : 0;
                    gradLon[numPointsSide-1][k] = numPointsSide > 1 ? (elevationGrid[numPointsSide-1][k+1] - elevationGrid[numPointsSide-1][k]) / lonSpacingMeters : 0;
                } else { 
                    gradLon[0][k] = numPointsSide > 1 ? (elevationGrid[0][k] - elevationGrid[0][k-1]) / lonSpacingMeters : 0;
                    gradLon[numPointsSide-1][k] = numPointsSide > 1 ? (elevationGrid[numPointsSide-1][k] - elevationGrid[numPointsSide-1][k-1]) / lonSpacingMeters : 0;
                }
                gradLat[0][k] = numPointsSide > 1 ? (elevationGrid[1][k] - elevationGrid[0][k]) / latSpacingMeters : 0;
                gradLat[numPointsSide-1][k] = numPointsSide > 1 ? (elevationGrid[numPointsSide-1][k] - elevationGrid[numPointsSide-2][k]) / latSpacingMeters : 0;
                
                if (k > 0 && k < numPointsSide - 1) {
                    gradLat[k][0] = (elevationGrid[k+1][0] - elevationGrid[k-1][0]) / (2 * latSpacingMeters); 
                    gradLon[k][0] = numPointsSide > 1 ? (elevationGrid[k][1] - elevationGrid[k][0]) / lonSpacingMeters : 0;
                    gradLat[k][numPointsSide-1] = (elevationGrid[k+1][numPointsSide-1] - elevationGrid[k-1][numPointsSide-1]) / (2 * latSpacingMeters);
                    gradLon[k][numPointsSide-1] = numPointsSide > 1 ? (elevationGrid[k][numPointsSide-1] - elevationGrid[k][numPointsSide-2]) / lonSpacingMeters : 0;
                }
            }
            if (numPointsSide === 1) { gradLat[0][0] = 0; gradLon[0][0] = 0; }
            
            const gradientMagnitudes = [];
            for (let i = 0; i < numPointsSide; i++) {
                for (let j = 0; j < numPointsSide; j++) {
                    gradientMagnitudes.push(Math.sqrt(gradLat[i][j]**2 + gradLon[i][j]**2));
                }
            }
            if (!lastMessageIsUniformElevationWarning) {
                 showMessage("Gradient magnitudes calculated.", false);
            }
            return gradientMagnitudes;
        }

        function createOrUpdateTopologyMap(centerLat, centerLon, gridPointsForApi, valuesForHeatmap, propertyMarkerCoords, acresBoundsCoords, inputAcres) {
            mapContainer.classList.remove('hidden');
            
            if (!map) {
                map = L.map('map').setView([centerLat, centerLon], 15);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
            } else { map.setView([centerLat, centerLon]); }

            if (heatLayer) map.removeLayer(heatLayer);
            if (propertyMarker) map.removeLayer(propertyMarker);
            if (boundsRectangle) map.removeLayer(boundsRectangle);

            const heatmapData = [];
            if (valuesForHeatmap && valuesForHeatmap.length > 0 && gridPointsForApi.length === valuesForHeatmap.length) {
                for (let i = 0; i < gridPointsForApi.length; i++) {
                    if (valuesForHeatmap[i] !== null && valuesForHeatmap[i] !== undefined && isFinite(valuesForHeatmap[i])) {
                        heatmapData.push([gridPointsForApi[i].lat, gridPointsForApi[i].lng, valuesForHeatmap[i]]);
                    }
                }
            }
            
            const allGradientsEffectivelyZero = valuesForHeatmap.every(v => v === 0 || (v && Math.abs(v) < 0.0001));

            if (heatmapData.length > 0 && !allGradientsEffectivelyZero) {
                 heatLayer = L.heatLayer(heatmapData, { radius: 20, blur: 15, maxZoom: 18 }).addTo(map);
                if (!lastMessageIsUniformElevationWarning) {
                    showMessage("Map updated with gradient heatmap.", false);
                }
            } else if (allGradientsEffectivelyZero && heatmapData.length > 0) {
                if (!lastMessageIsUniformElevationWarning) {
                    showMessage("Calculated gradient is uniformly zero. Terrain appears flat based on data; no heatmap variations visible.", false, true);
                }
            } else {
                showMessage("No valid data points to display on heatmap. Check console for API errors or data issues.", true);
            }

            if (propertyMarkerCoords) {
                propertyMarker = L.marker([propertyMarkerCoords.latitude, propertyMarkerCoords.longitude], {
                    icon: L.icon({ 
                        iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
                        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
                        shadowSize: [41, 41]
                    })
                }).addTo(map).bindPopup("<b>Property Location</b>").openPopup();
            }

            if (acresBoundsCoords) {
                boundsRectangle = L.rectangle([
                    [acresBoundsCoords[0], acresBoundsCoords[1]], 
                    [acresBoundsCoords[2], acresBoundsCoords[3]]
                ], { color: '#ff7800', weight: 2, fillOpacity: 0.05, fillColor: '#78a0ff' })
                .addTo(map).bindTooltip(`${inputAcres} Acres Area`);
                map.fitBounds(boundsRectangle.getBounds(), {padding: [20, 20]});
            } else if (propertyMarkerCoords) {
                 map.setView([propertyMarkerCoords.latitude, propertyMarkerCoords.longitude], 15);
            }
        }

        async function handleProcessRequest() {
            const addressStr = addressInput.value.trim();
            const acresStr = acresInput.value.trim();

            if (!addressStr) { showMessage("Please enter a street address.", true); return; }
            if (!acresStr) { showMessage("Please enter the number of acres.", true); return; }
            const acresVal = parseFloat(acresStr);
            if (isNaN(acresVal) || acresVal <= 0) { showMessage("Acres must be a positive number.", true); return; }
            if (NUM_POINTS_SIDE < 2) { showMessage("Configuration error: NUM_POINTS_SIDE must be at least 2.", true); return; }

            setLoadingState(true);
            messageArea.textContent = ''; 

            try {
                const propertyCoords = await geocodeAddressWithGoogle(addressStr);
                if (!propertyCoords) { setLoadingState(false); return; }
                console.log("Geocoded Property Coords:", propertyCoords);

                const gridData = getGridPointsAndSteps(propertyCoords.latitude, propertyCoords.longitude, acresVal, NUM_POINTS_SIDE);
                if (!gridData) { setLoadingState(false); return; }
                const { gridPointsForApi, latSpacingMeters, lonSpacingMeters, boundingBoxCoords } = gridData;
                
                const elevationValues = await getElevationsWithGoogle(gridPointsForApi);
                console.log("Processed Elevation Values (Google GET):", elevationValues);

                if (!elevationValues || elevationValues.length !== gridPointsForApi.length) {
                    setLoadingState(false);
                    if (!lastMessageIsUniformElevationWarning && !elevationValues) {
                        // Error message already shown by getElevationsWithGoogle
                    } else if (!lastMessageIsUniformElevationWarning) {
                         showMessage("Mismatch or incomplete elevation data received from Google GET.", true);
                    }
                    return;
                }
                
                const gradientMagnitudes = calculateGradientMagnitudes(elevationValues, NUM_POINTS_SIDE, latSpacingMeters, lonSpacingMeters);
                console.log("Calculated Gradient Magnitudes (Google GET):", gradientMagnitudes);

                if (!gradientMagnitudes) {
                    if (!lastMessageIsUniformElevationWarning) {
                        showMessage("Gradient calculation failed. Visualizing raw elevations instead if available.", true);
                    }
                    if (elevationValues && !lastMessageIsUniformElevationWarning) {
                         createOrUpdateTopologyMap(propertyCoords.latitude, propertyCoords.longitude, gridPointsForApi, elevationValues.map(e => e === null || e === undefined ? 0 : e), propertyCoords, boundingBoxCoords, acresVal);
                         showMessage("Displaying raw elevation data heatmap due to gradient calculation issue.", false, true);
                    } else if (!lastMessageIsUniformElevationWarning) {
                        showMessage("Could not calculate gradients or display raw elevations.", true);
                    } else { 
                         createOrUpdateTopologyMap(propertyCoords.latitude, propertyCoords.longitude, gridPointsForApi, [], propertyCoords, boundingBoxCoords, acresVal);
                    }
                } else {
                    createOrUpdateTopologyMap(propertyCoords.latitude, propertyCoords.longitude, gridPointsForApi, gradientMagnitudes, propertyCoords, boundingBoxCoords, acresVal);
                }

            } catch (error) {
                console.error("Main processing error:", error);
                showMessage(`An unexpected error occurred: ${error.message}`, true);
            } finally {
                setLoadingState(false);
            }
        }
    </script>
</body>
</html>
